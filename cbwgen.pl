#!/usr/bin/perl -w
use strict;
use warnings;
use feature qw(switch);
# use Switch;

#
# This example script generates ini files 
# and condor submission files for CBwaves
# to be submitted to Condor clusters.
#
# Modify it accordin to your needs.
#
# Set $generatesubfileonly = "no" below if 
# you want to run cbwaves on the fly.
#

# Definition of auxiliary variables

my $PI     = 3.141592653589793;
my $SI_c   = 2.99792458E8;
my $SI_G   = 6.67428E-11;
my $SI_Gc2 = 7.42613801611754e-28;
my $SI_ly  = 9460730472580800.0;
my $SI_pc  = 3.26156*$SI_ly;


# - Where is the cbwaves executable
my $cbwbinary="/Users/b/Documents/CppProjects/cbwaves-verziok/cbwaves-1.2.0-2/build/CBwaves";

# - Output file name prefix

my $filenameprefix="test";

# - Mass ratio: 10:1.4
#       m1 = 10*G/c^2*2e30 = 14850 meters
#	m2 = 1.4*G/c^2*2e30 = 2079 meters

my $msun = 1477;
my $m1 = 10*$msun;
my $m2 = 1.5*$msun;

my $M = $m1 + $m2;

# - Initial separation:
my $z = 0.3;
my $r = 15*($M*(1 + $z));
my $ri = $r;
# If $ri equal to $r, then the orbit will be closed, if they are not equal, then the orbit will be open (hiperbolic or parabolic).

# - Time step
my $dt = 2.4e-4;

# - Maximum evolution time
my $tmax = 1.0e12.0;

# - Maximum number of orbits
my $orbitsmax = 1.0e12;

# - Eccentricity of the orbit
my $epsilon = 0;

# - Polar angles
my $iota    = 0.0;
my $phi     = 0.0;
my $theta   = 0.0;
my $varphi  = 0.0;
my $psi     = 0.0;

# - Spin definition
my ($s1x, $s1y, $s1z) = (-sin(0.1020645929),0,cos(0.1020645929));
my ($s2x, $s2y, $s2z) = (sin(0.4215341828),0,cos(0.4215341828));

# - Output filename definition
my $outfile="cbwaves.out";
my $ftfile="cbwaves.ft";

# - Hterms and corrections
my $hterms= "'Q','P05Q','PQ','P15Q','P15Qtail','PQSO','P15QSO','P2Q','PQSS'";
my $corrs="'PN','2PN','RR','3PN','1RR','2PNSO','4PN'";

# - Output variables
#my $outvars = "t,orbits,orbfreq,rx,ry,rz,h_+,E_N,E_PNtot,E_tot,E_rad,hp22,hx22,x1,y1,z1,x2,y2,z2,hp22,hp21,hp20,hp2m1,hp2m2,hx22,hx21,hx20,hx2m1,hx2m2,h_x,h,mr,v2";
my $outvars = "t,x1,y1,z1,x2,y2,z2,E,E_tot,h,r,r_tot";

# - Do we want initial eccentricity approximation 
my $eccapprox = "no";

# - Do we want checkpointing 
my $checkpoint = "no";

# - What is the description of the run - to be used for the checkpoint files
my $description = "testrun";

# - We want only to generate condor submission files
my $generatesubfileonly = "no";

# - distance from observer: D = 2*mu = 2*m1*m2/(m1+m2)
my $D = 8000000*$SI_pc;

# - orbital time (defined here, set later)
my $T = 10;

# - orbit frequency
my $f = 1/$T;

# - logging level
my $loglevel = 6;

# - simulations stops when r<rmin or r>rmax
my $rmin = 6*($m1 + $m2);
my $rmax = 99999999999999.;

# - loop variables
my $i;
my $j;

# print variables
my $printstep = 10;
my $printorbit = 0;
my $adaptive = "no";
my $adaptive_step = 1000;


# - gauge parameters for RR
my $eta     = $m1 * $m2 / ($m1 + $m2) / ($m1 + $m2);
my $galpha  = 4;
my $gbeta   = 5;
my $gdelta1 = -99./14.+27.*$eta;
my $gdelta2 = 5.*(1. - 4.*$eta);
my $gdelta3 = 274./7. + 67./21.*$eta;
my $gdelta4 = 5./2.*(1. - $eta);
my $gdelta5 = -1./7.*(292. + 57.*$eta);
my $gdelta6 = 51./28. + 71./14.*$eta;


#
# Subroutine declarations
#

sub Run {
	my ($cmd) = @_;
        printf(STDERR "%s\n", $cmd);
        system($cmd);
}

sub WriteInifile {

open(myFILE,">CBwaves.ini");
print myFILE <<EOF;

#
# Initialization file for the CBwaves executable
#       generated by cbwgen.pl
#

[output]
outfile = $outfile              # output filename
ftfile = $ftfile                # file for the Fourier-transformed
outvars = $outvars

[input]
m1        = $m1                         # mass of bigger star
m2        = $m2                         # mass of lighter star
tmax      = $tmax                       # maximum evolution time
orbitsmax = $orbitsmax                  # maximum number of revolutions
T         = $T		                # orbit time
f         = $f                          # orbiting frequency
dt        = $dt                         # RK4 time step
epsilon   = $epsilon                    # eccentricity
rmin      = $rmin                       # final relative distance
rmax      = $rmax                       # final relative distance
r         = $r                          # initial separation
ri        = $ri                         # initial separation for hyperbolic orbits
D         = $D                          # distance to observer
iota      = $iota                       # polar angle in the source frame
phi       = $phi                        # polar angle in the source fram
theta     = $theta                      # Euler angle between TT and detector frame
varphi    = $varphi                     # Euler angle between TT and detector frame
psi       = $psi                        # Euler angle between TT and detector frame
s1x       = $s1x                        # spin x components of m1
s1y       = $s1y                        # spin y components of m1
s1z       = $s1z                        # spin z components of m1
s2x       = $s2x                        # spin x components of m2
s2y       = $s2y                        # spin y components of m2
s2z       = $s2z                        # spin z components of m2
hterms    = $hterms                     # PN order for the waveform
corrs     = $corrs                      # PN order for the motion
eccapprox = $eccapprox                  # approximate or not the initial eccentricity
checkpoint= $checkpoint                 # wheter to make or not checkpoint files
description=$description                # human readable description of the run
printstep = $printstep                  # print variables after every X step
printorbit = $printorbit                # print variables after every X orbit
loglevel  = $loglevel                   # logging level (0 - 6)
adaptive   = $adaptive                  # apply adaptive time step or not
adaptive_step   = $adaptive_step        # how many time step per revolution
alpha  = $galpha;                       # newtonian radiation term gauge parameter
beta   = $gbeta;                        # newtonian radiation term gauge parameter
delta1 = $gdelta1;                      # post-newtonian radiation term gauge parameter
delta2 = $gdelta2;                      # post-newtonian radiation term gauge parameter
delta3 = $gdelta3;                      # post-newtonian radiation term gauge parameter
delta4 = $gdelta4;                      # post-newtonian radiation term gauge parameter
delta5 = $gdelta5;                      # post-newtonian radiation term gauge parameter
delta6 = $gdelta6;                      # post-newtonian radiation term gauge parameter

EOF
close(myFILE);
}

#
# Here it starts a loop on the parameters and generation of ini files
#

my $uniqid=""; # for unique file name definition
my $flow;      # the initial orbital frequency
my $s;         # aux variable for the spin
my $alpha;     # aux variable angle for the spin angle

# my $date = strftime "%a%e%Y", localtime;


# Generation of the ini files - modify the loops according to your needs

# Comment out the the loops if you want to generate only
# a single ini file.

#for ($i=1; $i <5; $i++) {
# $i=10;

my @orders = qw(PN 2PN 3PN 4PN );
my $PNorder = "";
foreach $PNorder (@orders) {

        $outvars = "t,E_tot,r,E_PN,E_2PN,E_3PN,E_4PN,E_PNrad,E_2PNrad,E_PNtot,E_2PNtot,x2,y2";

        # print "${PNorder} \n";

        given($PNorder){

                when ("PN")       { $corrs="'PN','RR','1RR'"; print "PN test is runing.\n"; }
                when ("2PN")      { $corrs="'PN','2PN','RR','1RR','2PNSO'"; print "2PN test is runing.\n"; }
                when ("3PN")      { $corrs="'PN','2PN','RR','3PN','1RR','2PNSO'"; print "3PN test is runing.\n"; }
                when ("4PN")      { $corrs="'PN','2PN','RR','3PN','1RR','2PNSO','4PN'"; print "4PN test is runing.\n"; }
                default	          { $corrs="'PN','2PN','RR','3PN','1RR','2PNSO','4PN'"; }

        }

        $m1  = 10. * $msun;
        $m2  = 5. * $msun;
        $s1x = 0.;
        $s1y = 0.;
        $s1z = 0.;
        $s2x = 0.;
        $s2y = 0.;
        $s2z = 0.;
        $epsilon = 0.;
        
        $uniqid="${filenameprefix}_${PNorder}";
        $outfile="${uniqid}.dat";
        # $ftfile="${filenameprefix}_${i}_${i}_fft"; 

        $rmin = 2*$M;
        # $flow = 40;
        # $r  = (($SI_c/2./$PI/$flow)**2.*($m1+$m2) )**(1./3.);
        $r = 50*($M*(1 + $z));
        $ri = $r;
        $T  = 2*$PI*sqrt($r**3./($m1+$m2))/$SI_c; # To calculate orbital steps
        $f  = 1 / $T;
        $dt = 1 / 4096;
        $rmax = 100*$r;

        WriteInifile;
    
        Run "cp CBwaves.ini ${uniqid}.ini";
        if ("$generatesubfileonly" eq "yes") {
           open(desFILE,"> ${uniqid}.des");
           print desFILE <<EOF;

########################
# Submission file for CBwaves
########################
Executable              = ${cbwbinary}
Universe                = vanilla
Arguments               = ${uniqid}.ini
Output                  = ${uniqid}.out
Error                   = ${uniqid}.err
Log                     = ${uniqid}.log
Queue 1
EOF
          
        } else {
                Run "/Users/b/Documents/CppProjects/cbwaves-verziok/cbwaves-1.2.0-2/build/CBwaves ${uniqid}.ini";
       }
    
}

print "\n Subroutines \n";
Run "gnuplot plot.gpl";

Run "rm -rf data/";
Run "mkdir data";
Run "mv *.dat data/";
Run "mv *.png data/";
